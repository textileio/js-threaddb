<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@textile/threaddb</title>
	<meta name="description" content="Documentation for @textile/threaddb">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@textile/threaddb</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>@textile/threaddb</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p>Javascript implementation of Textile&#39;s ThreadDB</p>
				<p><a href="https://textile.io"><img src="https://img.shields.io/badge/made%20by-Textile-informational.svg" alt="Textile"></a>
					<a href="https://slack.textile.io"><img src="https://img.shields.io/badge/slack-slack.textile.io-informational.svg" alt="Slack"></a>
					<a href="./LICENSE"><img src="https://img.shields.io/github/license/textileio/js-threaddb.svg" alt="License"></a>
				<a href="https://www.npmjs.com/package/@textile/threaddb"><img src="https://img.shields.io/npm/v/@textile/threaddb.svg" alt="Release"></a></p>
				<p><img src="https://github.com/textileio/js-threaddb/workflows/Test/badge.svg" alt="Test">
				<a href="https://textileio.github.io/js-threaddb"><img src="https://github.com/textileio/js-threaddb/workflows/Docs/badge.svg" alt="Docs"></a></p>
				<blockquote>
					<p>An offline-first local db that syncs to the distributed web.</p>
				</blockquote>
				<p><strong>This project is pre-release, do not use it in production, breaking changes will still occur without notice.</strong></p>
				<a href="#getting-help" id="getting-help" style="color: inherit; text-decoration: none;">
					<h2>Getting help</h2>
				</a>
				<p>The Textile/Threads developers/community are active on <a href="https://slack.textile.io/">Slack</a> and <a href="https://twitter.com/textileio">Twitter (@textileio)</a>, join us there for news, discussions, questions, and status updates. Also, <a href="https://blog.textile.io">check out our blog</a> for the latest posts and announcements.</p>
				<p>If you think you&#39;ve found a bug, please file a github issue. Take a look at our comprehensive <a href="#contributing">contributor guide</a> for details on how to get started.</p>
				<a href="#background" id="background" style="color: inherit; text-decoration: none;">
					<h2>Background</h2>
				</a>
				<blockquote>
					<p>See this 5-minute project overview video to get a feel for the underlying project structure, and how we’re conceptualizing the new ThreadDB in Javascript.</p>
				</blockquote>
				<p><a href="https://www.loom.com/share/3d7ec496c3d744a39d85e3fc3e921b7d">Project overview video</a></p>
				<p>Let&#39;s start with some of the motivations around our new approach to ThreadDB, and our shift from &quot;Threads the database&quot; to &quot;Threads the database syncing mechanism&quot;.</p>
				<ul>
					<li><strong>Local first</strong>. The concept of offline-first or local-first software isn’t a new one. There are some great discussions (<a href="https://blog.acolyer.org/2019/11/20/local-first-software/">and summaries</a>) of the ideas out there already, and we encourage you to take a look. User ownership of data, interoperability, collaboration, offline-capable, etc are all ideals we appreciate.</li>
					<li><strong>Usability</strong>. This one doesn’t get discussed as much in the context of offline-first software, but it is actually way easier to test and develop apps that don’t actually require real-time access to any remote services. As you’ll see in some of our demo videos below, you can spend a good chunk of time testing, validating, and breaking things before you even touch a “live” remote API. This means less garbage data while developing, while at the same time leveraging and testing against the real APIs you’ll encounter once you move to production.</li>
					<li><strong>Flexibility</strong>. Why should a developer looking to leverage Threads in their workflow have to migrate to a new database implementation, when there are already lots of great databases out there? Wouldn’t it be great if you could just use the right database for the job, and then simply have that database sync to web3 automatically? We think so, and this is part of what we are exploring with this release of ThreadDB.</li>
				</ul>
				<p>When thinking about the above constraints (plus a whole lot of technical considerations), we landed on a simple, but powerful framework for our new vision of ThreadDB for Javascript. This early release addresses the local-first database component by leveraging <a href="https://github.com/dfahlander/Dexie.js">IndexedDB, via Dexie</a>. This provides a lightweight, easy to use database, where all the complexity of remote sync is separated from the complexity of the database itself. The database features a MongoDB-like experience, with change tracking, custom UUIDs, and more. For those already familiar with Dexie, you can peel back the layers to have direct access to the Dexie database object for even more control over your local database experience. Check out the <a href="#getting-started">getting started section</a> to get a feel for the basic APIs provided by Textile. There, you’ll see what is required to go from basic interactions with a local ThreadDB Database to pushing those local changes to a Remote.</p>
				<a href="#modular" id="modular" style="color: inherit; text-decoration: none;">
					<h3>Modular</h3>
				</a>
				<p>ThreadDB for Javascript contains a fully-featured local-first database (Dexie) and a set of remote features that enable sync, archive, and recovery over the network. The <code>Remote</code> object itself simply defines several middlewares that intercept Dexie calls, store the list of updates in a local sandbox, and then provides tooling to push, pull, rebase, and stash these local changes with a remote Thread daemon.</p>
				<p>The project design is purposefully modular, and is organized roughly into three components: the &quot;local&quot; store, the &quot;middleware&quot;, and the communication with a &quot;remote&quot;. Ideally, the &quot;local&quot; component is minimal, and provides only a light wrapper around a local database. In our case, that database is IndexedDB via Dexie, but in theory, almost any local database will eventually work. The middleware is similarly light-weight. Here, we provides a few sub-modules for hooking into the local database to extract the things we need to communicate with the remote module. It additionally provides a few middleware components that provide MongoDB style queries, track changes, custom UUIDs, schemas, and more. Those familiar with our existing <a href="https://github.com/textileio/js-threads">Threads Client</a> library will notice several useful similarities.</p>
				<p>That brings us to the &quot;remote&quot; module. This is where the magic of syncing to the decentralized web happens. In practice, we&#39;re leveraging existing Textile APIs to validate this proof-of-concept model. Eventually, as we optimize what is going on under the hood, we’ll roll out new APIs that are more efficient, and provide more useful functionality in an offline-first scenario. Essentially, we track changes on the local database, and provide low level APIs to push, pull, and resolve any conflicts that arise when syncing with a remote. In general, the remote is considered the &quot;source of truth&quot; in any real conflicts, and ThreadDB is designed to be used more as a federated system of peers, rather than pure peer-to-peer. As such, each local &quot;remote&quot; module connects to one remote daemon at a time, and relies on that daemon for network operations and syncing. By default, remotes are configured to work against Textile&#39;s Hub daemon, but as a developer, you have easy access to setting this to other remote hosts.</p>
				<a href="#getting-started" id="getting-started" style="color: inherit; text-decoration: none;">
					<h2>Getting Started</h2>
				</a>
				<blockquote>
					<p>Check out this &quot;getting started&quot; video to get a feel for the basic APIs. In it, you&#39;ll see what is required to go from basic interactions with a local ThreadDB Database to pushing those local changes to a Remote Daemon.</p>
				</blockquote>
				<p><a href="https://www.loom.com/share/ecebf43e0eda4376a389ceadb234fdb3">Getting started video</a></p>
				<p>Before digging into the specifics of ThreadDB, you’ll likely want to familiarize yourself with existing Textile <a href="https://docs.textile.io/">developer tooling</a>. In particular, if you are planning to use ThreadDB against Textile’s Hub, you’ll want to make sure you have a <a href="https://docs.textile.io/hub/accounts/">developer account setup</a>, and likely want to create some <a href="https://docs.textile.io/hub/apis/">new keys for testing</a> etc. For the purposes of testing and building toy examples, we recommend, you stick with <a href="https://docs.textile.io/tutorials/hub/development-mode/">development mode</a>.</p>
				<p>Additionally, for this early release, we’ve tried to keep the Database APIs relatively similar to our existing Thread Client library. That means ThreadDB supports Collections and Instances, very similarly to what we <a href="https://docs.textile.io/threads/">already have going on over here</a>. We <em>highly recommend</em> you take a look at those existing docs before proceeding.</p>
				<p>Assuming you have a developer account setup, and you’ve read the docs (seriously, <a href="https://docs.textile.io/threads/#collections">read the docs</a>), let’s get started. The following examples are taken directly from the above getting started video. So feel free to follow along, copy/paste the code snippets, and start testing things. The demo videos and most of our examples are in Typescript, but we provide a vanilla <a href="#advanced">Javascript React demo</a> below as well. Additionally, you can use any environment you are comfortable with, including browser apps via a bundler such as webpack or rollup, or directly in Node/Deno. For the brave, you can access the existing <a href="https://observablehq.com/@carsonfarmer/threaddb-usage-demo/2">Notebook</a> directly.</p>
				<a href="#install" id="install" style="color: inherit; text-decoration: none;">
					<h3>Install</h3>
				</a>
				<p>Start by creating a new npm project. Just stick with the defaults here, we’re not going to need anything fancy:</p>
				<pre><code class="language-bash">
mkdir demo-project
<span class="hljs-built_in">cd</span> demo-project
npm init
<span class="hljs-comment"># Defaults are fine</span></code></pre>
				<p>Now you can install the required Textile modules. For this first mini-demo, we’ll stick with the minimal setup (we’re including <code>threads-client</code> here for validation later):</p>
				<pre><code class="language-bash">npm i @textile/threaddb @textile/crypto @textile/threads-id @textile/threads-client</code></pre>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h3>Usage</h3>
				</a>
				<p>With those in place, we’re ready to start interacting with the Database. If you’re running this code in NodeJS, it will automatically include an IndexedDB polyfill to store data in SQLite, otherwise (in a browser) it should leverage the embedded IndexedDB database.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Database } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@textile/threaddb&quot;</span>;
<span class="hljs-keyword">import</span> { schema, Person } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./schema&quot;</span>; <span class="hljs-comment">// Some json-schema.org schema</span></code></pre>
				<p>One of the design constraints we set for ourselves when building ThreadDB was to ensure that a developer or user could get up and going with ThreadDB without an internet connection, and without any prior orchestration with a remote. So to create a new Database is as easy as:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// Create an empty db, with a defined schema, and open it</span>
<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> Database(<span class="hljs-string">&quot;demo&quot;</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Person&quot;</span>, schema });
<span class="hljs-keyword">await</span>.open(<span class="hljs-number">1</span>); <span class="hljs-comment">// Versioned db on open</span></code></pre>
				<p>We make a few assumptions to make this easy. 1. That the developer knows the schema(s) that they want to use for their Collections ahead of time, and 2. That a change in schemas will result in a change in the database version (so we also have versioned databases, thanks to Dexie).</p>
				<p>Now, we just start using it. Similarly to MongoDB you can get a given Collection, and you can insert data into it. In our case, it will do schema validation on the way in.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> Person = db.collection(<span class="hljs-string">&quot;Person&quot;</span>);
<span class="hljs-keyword">await</span> Person.insert({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Someone&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">37</span> });
<span class="hljs-comment">// [ &#x27;01ENVC6YJ94K0DVXXESQJYE8WD&#x27; ]</span></code></pre>
				<p>Because it is often useful to create an Instance before inserting it into the database, you can do that via the <code>create</code> method on a Collection:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> entity = Person.create({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Other&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">2</span> });
<span class="hljs-keyword">await</span> entity.exists(); <span class="hljs-comment">// false</span>
<span class="hljs-keyword">await</span> Person.has(entity._id); <span class="hljs-comment">// false</span></code></pre>
				<p>All instances have an <code>_id</code> property like in MongoDB, which in our case, is a <a href="https://github.com/ulid/spec">Ulid</a>. Once we have an instance, it has many useful properties that allow us to save, check if it exists in the database, delete, etc.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">await</span> entity.save(); <span class="hljs-comment">// Write to the local store</span>
<span class="hljs-keyword">await</span> entity.exists(); <span class="hljs-comment">// true</span></code></pre>
				<p>As with any reasonable database, you can query it, grab all Instances, count things, etc. We provide some nice MongoDB style querying, but you also have access to the full suite of query tools provided by Dexie if you want them:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">await</span> Person.find({}).count(); <span class="hljs-comment">// Should be at least 2</span></code></pre>
				<p>Similarly, things like transactions are supported by ThreadDB. We have readTransaction and writeTransaction support, which matches our Go implementation to some degree. These are useful for batch inserts and for providing proper isolation and automaticity guarantees:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Someting&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">4</span> };
<span class="hljs-keyword">await</span> Person.writeTransaction(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [id] = <span class="hljs-keyword">await</span> Person.insert(person);
});</code></pre>
				<p>By the way, <code>insert</code> and many other methods take a variadic list of inputs, which makes it easy to do bulk inserts even when not using a transaction explicitly.</p>
				<p>And of course, more complex queries are possible thanks to the (subset of) MongoDB query language that ThreadDB supports:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> people = Person.find({
  <span class="hljs-attr">$or</span>: [{ <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gt</span>: <span class="hljs-number">2</span> } }, { <span class="hljs-attr">name</span>: { <span class="hljs-attr">$eq</span>: <span class="hljs-string">&quot;Something&quot;</span> } }],
}); <span class="hljs-comment">// Should still find all of them!</span>
<span class="hljs-keyword">await</span> people.toArray();</code></pre>
				<a href="#remotes" id="remotes" style="color: inherit; text-decoration: none;">
					<h3>Remotes</h3>
				</a>
				<p>So far, we’ve only be doing local operations. Now it’s time to interact with a remote daemon. If you aren’t familiar with Textile’s Thread daemons, we recommend you <a href="https://github.com/textileio/go-threads">read up on them here</a>. The protocols and design of ThreadDB can be explored in detail in the white-paper: <a href="https://docsend.com/view/gu3ywqi">A protocol &amp; event-sourced database for decentralized user-siloed data</a>. For further technical details. the reference implementation of Threads is written in Go and the full implementation details can be found on <a href="https://godoc.org/github.com/textileio/go-threads">godocs</a>. But for now, let’s simply connect to the Hub’s remote Threads daemon, so we don’t have to worry about running our own.</p>
				<p>For working against the Hub, you’ll need a developer key, see the links above for some examples on how to generate this. We recommend starting with an insecure key for developing locally, before upgrading to a production setup.</p>
				<blockquote>
					<p>Please remember to use your own keys, rather than the demos keys provided in the Notebook!</p>
				</blockquote>
				<pre><code class="language-typescript"><span class="hljs-comment">// Set key info (assumes this is an insecure key)</span>
<span class="hljs-keyword">const</span> key = d<span class="hljs-string">&quot;&quot;</span>
<span class="hljs-comment">// Specify the key here, remote defaults to Hub APIs so no need to set</span>
<span class="hljs-keyword">const</span> remote = <span class="hljs-keyword">await</span> db.remote.setKeyInfo({ key })</code></pre>
				<p>Once we&#39;ve &quot;set&quot; our remote, it is pretty easy to start working against it. But there are two things we need to do before we can start pushing data. The first, is to authenticate our local &quot;user&quot; or database instance, with the remote. This is required, regardless of the remote Threads daemon we are connecting with, be it the Hub, or our own daemon running on our laptop. Authentication is always against a public key (defaulting to an ED25519 signing pair). ThreadDB makes this super easy if you are working with our default key objects:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { PrivateKey } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@textile/crypto&quot;</span>;
<span class="hljs-comment">// New random identity</span>
<span class="hljs-keyword">const</span> privateKey = PrivateKey.fromRandom();
<span class="hljs-comment">// Grab the token, save it, or just use it</span>
<span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> remote.authorize(privateKey);
<span class="hljs-built_in">console</span>.log(token);</code></pre>
				<p>The response from <code>remote.authorize</code> is a token string. This is actually automatically added to the remote&#39;s metadata under the hood, but since this token doesn&#39;t expire, a developer might wish to store this in the user&#39;s <code>localStorage</code>, or otherwise cache this information. You could even store the token within the user&#39;s database if you wanted, though be advised, you should probably encrypt it if you are going to persist it anywhere insecure.</p>
				<p>Now we’re ready to start working against the remote. The first thing you’ll likely want to do, is initialize a new database on the remote. This is essentially allocating a new Thread, and pushing the local schema information to the remote database. In practice, you’ll likely want to do this the first time a user connects with the remote daemon, and only then. But ThreadDB makes this operation pretty much idempotent, so if you accidentally try to initialize twice, you shouldn’t end up with more than one database on the remote. We’ll be working further to make this easier, so that it will detect version changes and things like that to handle schema changes “on the fly”.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> id = <span class="hljs-keyword">await</span> remote.initialize(); <span class="hljs-comment">// Create random thread</span>
<span class="hljs-built_in">console</span>.log(id);</code></pre>
				<p>Of course, if you already have a Thread ID in mind, you can provide that string to the initialize method. This is a good idea if you want to invite another peer to your Thread that was created by a different peer, or if you have a “static” Thread that all users are going to interact with.</p>
				<p>Now you just push…</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">await</span> remote.push(<span class="hljs-string">&quot;Person&quot;</span>); <span class="hljs-comment">// That&#x27;s it</span></code></pre>
				<p>Assuming no conflicts or issues with connecting to the remote, you’re off to the races. We can actually use our existing Threads Client library to validate that our changes were indeed pushed:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Client } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@textile/threads-client&quot;</span>;
<span class="hljs-keyword">import</span> { ThreadID } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@textile/threads-id&quot;</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">await</span> Client.withKeyInfo({ key });
<span class="hljs-comment">// Grab context just for our demo, not really needed</span>
<span class="hljs-keyword">const</span> context = client.context.withToken(token);
<span class="hljs-keyword">const</span> found = <span class="hljs-keyword">await</span> client.find(ThreadID.fromString(id), <span class="hljs-string">&quot;Person&quot;</span>, {});
<span class="hljs-built_in">console</span>.log(found);</code></pre>
				<p>If all went according to plan, you should have the same set of instances on the remote as you do locally. Now try pushing more updates, or creating updates directly on the remote and pulling them into your local state. The remote API also has tools to “stash”, and “rebase” local changes on top of remote changes, and all sorts of additional tooling.</p>
				<a href="#development" id="development" style="color: inherit; text-decoration: none;">
					<h3>Development</h3>
				</a>
				<p>Interested in submitting a PR or getting more directly involved in ThreadDB development?Awesome, we’ll gladly accept PRs, issues, and ideas. Just keep in mind that this is an early testing preview release, so things are likely to change significantly.</p>
				<blockquote>
					<p>Once the project stabilizes it will be moved into our existing js-textile mono-repo for further development… this shouldn’t change things much, but is something to watch out for.</p>
				</blockquote>
				<p>Either way, start by cloning and digging into the repo:</p>
				<pre><code class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:textileio/js-threaddb.git
<span class="hljs-built_in">cd</span> threaddb</code></pre>
				<p>Next, install the required <code>npm</code> modules:</p>
				<pre><code class="language-bash">npm i</code></pre>
				<a href="#tests" id="tests" style="color: inherit; text-decoration: none;">
					<h3>Tests</h3>
				</a>
				<p>For now, you&#39;ll need to have a local <code>threadd</code> daemon running. The easiest way to do this is via <code>docker-compose</code>. You can use the following <code>docker-compose.yml</code> file:</p>
				<pre><code class="language-yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">threads:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">textile/go-threads:latest</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./repo/threads:/data/threads&quot;</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">THRDS_HOSTADDR=/ip4/0.0.0.0/tcp/4006</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">THRDS_APIADDR=/ip4/0.0.0.0/tcp/6006</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">THRDS_APIPROXYADDR=/ip4/0.0.0.0/tcp/6007</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">THRDS_DEBUG=true</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;4006:4006&quot;</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:6006:6006&quot;</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:6007:6007&quot;</span></code></pre>
				<p>With the above <code>yml</code> file, run the following:</p>
				<pre><code class="language-bash">docker-compose pull
docker-compose up</code></pre>
				<p>And then start some tests:</p>
				<pre><code class="language-bash">npm run <span class="hljs-built_in">test</span></code></pre>
				<p>Test coverage is pretty comprehensive, and you should get a coverage report upon running the tests (coverage is generated from the node tests):</p>
				<pre><code class="language-bash">npm run <span class="hljs-built_in">test</span>:node</code></pre>
				<p>Browser tests are run via <code>polendina</code>, and the tests are built on-the-fly using webpack (this is the only thing webpack is used for). The <code>webpack.test.js</code> config is used to enable <code>polendina</code> testing in typescript modules.</p>
				<pre><code class="language-bash">npm run <span class="hljs-built_in">test</span>:browser</code></pre>
				<a href="#build" id="build" style="color: inherit; text-decoration: none;">
					<h3>Build</h3>
				</a>
				<p>We use <code>tsc</code> to build our nodejs-based javascript outputs, and <code>rollup</code> for a single-file bundle. This makes it easier to derive different output types (e.g., commonjs vs es modules vs type defs). To create the relevant build outputs simply call:</p>
				<pre><code class="language-bash">npm run build</code></pre>
				<p>This should produce a dist folder with multiple output types. These are referenced in the <code>package.json</code>&#39;s <code>exports</code> entry, so that the right module types are used in the right context (i.e., <code>import</code> vs <code>require</code>). Note that a single-file ES6 module is output for browsers.</p>
				<a href="#releasing" id="releasing" style="color: inherit; text-decoration: none;">
					<h3>Releasing</h3>
				</a>
				<p>We&#39;ll try to be pretty serious about semantic versioning. To help us with this, we use conventional commits (and some <code>commitlint</code> hooks/linters) as well as automatically-generated conventional changelogs (via <code>standard-version</code>). To create a new version/release simply call:</p>
				<pre><code class="language-bash">npm run version</code></pre>
				<p>And then follow the standard <code>npm</code> publishing workflow from there.</p>
				<a href="#environment" id="environment" style="color: inherit; text-decoration: none;">
					<h3>Environment</h3>
				</a>
				<p>If you are working in vscode or vscodium, the following local settings are useful for testing:</p>
				<pre><code class="language-json">{
  <span class="hljs-attr">&quot;typescript.tsdk&quot;</span>: <span class="hljs-string">&quot;node_modules/typescript/lib&quot;</span>,
  <span class="hljs-attr">&quot;mochaExplorer.files&quot;</span>: <span class="hljs-string">&quot;**/*.spec.ts&quot;</span>,
  <span class="hljs-attr">&quot;mochaExplorer.esmLoader&quot;</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">&quot;mochaExplorer.exit&quot;</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">&quot;mochaExplorer.require&quot;</span>: [<span class="hljs-string">&quot;ts-node/register&quot;</span>, <span class="hljs-string">&quot;source-map-support/register&quot;</span>],
  <span class="hljs-attr">&quot;mochaExplorer.launcherScript&quot;</span>: <span class="hljs-string">&quot;node_modules/mocha-explorer-launcher-scripts/nyc&quot;</span>,
  <span class="hljs-attr">&quot;mochaExplorer.env&quot;</span>: {
    <span class="hljs-attr">&quot;TS_NODE_FILES&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,
    <span class="hljs-attr">&quot;TS_NODE_COMPILER_OPTIONS&quot;</span>: <span class="hljs-string">&quot;{\&quot;module\&quot;: \&quot;commonjs\&quot; }&quot;</span>
  }
}</code></pre>
				<p>These settings pair nicely with the <code>hbenl.vscode-mocha-test-adapter</code> and <code>ryanluker.vscode-coverage-gutters</code> plugins. I also highly recommend <code>dbaeumer.vscode-eslint</code> for in-editor linting. Note that we also use prettier for code formatting (called via eslint).</p>
				<a href="#api" id="api" style="color: inherit; text-decoration: none;">
					<h2>API</h2>
				</a>
				<p>We’re still in pre-release stage, so API docs are pretty minimal. You can generate them yourself by running <code>npm run docs</code>. This uses typedoc to build the docs. Additionally, some of the context APIs are the same as our existing threads-client APIs, so please refer to those docs for reference.</p>
				<a href="#maintainers" id="maintainers" style="color: inherit; text-decoration: none;">
					<h2>Maintainers</h2>
				</a>
				<p><a href="https://github.com/carsonfarmer">Carson Farmer</a></p>
				<a href="#contributing" id="contributing" style="color: inherit; text-decoration: none;">
					<h2>Contributing</h2>
				</a>
				<p>PRs gratefully accepted! Please see above for details on getting started.</p>
				<a href="#license" id="license" style="color: inherit; text-decoration: none;">
					<h2>License</h2>
				</a>
				<p><a href="./LICENSE">MIT</a> (c) 2019-2020 Textile</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/collection.html" class="tsd-kind-icon">Collection</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/database.html" class="tsd-kind-icon">Database</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/remote.html" class="tsd-kind-icon">Remote</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/collectionconfig.html" class="tsd-kind-icon">Collection<wbr>Config</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/documentinstanceconstructor.html" class="tsd-kind-icon">Document<wbr>Instance<wbr>Constructor</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/index.html" class="tsd-kind-icon">Index</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/instance.html" class="tsd-kind-icon">Instance</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/remoteconfig.html" class="tsd-kind-icon">Remote<wbr>Config</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#document" class="tsd-kind-icon">Document</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#threadidname" class="tsd-kind-icon">ThreadIDName</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#decoder" class="tsd-kind-icon">decoder</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#encoder" class="tsd-kind-icon">encoder</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#documentinstanceclassfactory" class="tsd-kind-icon">Document<wbr>Instance<wbr>Class<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#errors" class="tsd-kind-icon">Errors</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer>
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>